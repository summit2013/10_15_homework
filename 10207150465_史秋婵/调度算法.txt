*作业一：
#include <stdio.h>
#include <conio.h>
#define N 20
//进程控制块结构
typedef struct pcb
{char pName[N]; //进程名 
 int pArriveTime; //到达时间 
 int pRunTime; //估计运行时间  
 char pState; //进程状态  
 struct pcb* pNext; //链接指针
}PCB;
PCB head_input;     //链表头
int sysTime;         //自定义系统时间
int num=0;         //进程总数
void CreateProcessList()      //定义建立进程函数
 { PCB* pcs1;  
   PCB* pcs2;  
   printf("请输入进程个数:\n");    //输入进程个数  
   scanf("%d",&num);  
   getchar();  
   pcs1=&head_input; 
   pcs2=pcs1;  
   for (int i=0;i<num;i++)       //依次接受进程的信息  
    { pcs1->pNext=new PCB;   
      pcs2=pcs1;  
      pcs1=pcs1->pNext;   
      printf("输入进程号为 No.%3d 的进程名 pName:",i+1);   
      scanf("%s",pcs1->pName);  
      getchar();   
      printf("进程运行时间 pRunTime:");    
      scanf("%d",&pcs1->pRunTime);  
      getchar();    
      printf("进程到达时间 pArriveTime:"); 
      scanf("%d",&pcs1->pArriveTime);   
      getchar();    //建立进程队列   
      pcs1->pRunTime=(pcs1->pRunTime)*1000;   
      pcs1->pArriveTime=(pcs1->pArriveTime)*1000;   
      pcs1->pState='R';     //设置进程状态为就绪  
    }  
   pcs1->pNext=NULL;   //最后一个为空节点   
   printf("\n");
 }
//由于进程是有序的到达的，所以依次顺序执行输出操作
void ExecProcessList() 
 { PCB* pcs1; 
   PCB* pcs2;  
   int timeUsed=0;    //每个进程调度时间 
   int freeTime=0;    //没有进程执行的空闲时间  
   int totalTimeUsed=0;   //总的调度时间   
   pcs1=head_input.pNext;  
   while(pcs1!=NULL) 
   {
　　pcs1=head_input.pNext;     //pcs1指向对头的下一个进程    
    if (pcs1->pArriveTime/1000>sysTime)   //此时没有进程在进程队列里面等待    
     { freeTime=pcs1->pArriveTime/1000-sysTime;     
       for (int i=0;i<freeTime;i++)       
         {//每输出一次，系统时间增加一秒        
          printf("系统时间 sysTime:%3d.\n",sysTime);       
          sysTime++;        
          printf("进程队列里没有等待进程.\n\n");    
         }  
     }    //此时已经有进程到达  
   else if (pcs1->pArriveTime/1000<=sysTime)   
    { //输出每次运行的统计信息     
      for (int j=0;j<(pcs1->pRunTime)/1000;j++)   
        { //输出系统时间作为参照       
          printf("系统时间 sysTime:%3d.\n",sysTime);     
          if (0==j)       
           {//到达进程开始执行         
             printf("进程 %s 开始运行.\n\n",pcs1->pName);         
           }     
         printf("进程 %s 正在运行.\n",pcs1->pName);       
         printf("已经运行时间:%3d.\n",j+1);      
         printf("剩余时间:%3d.\n",(pcs1->pRunTime/1000)-(j+1));     
        //判断此时还有哪些进程在队列里面    
        pcs2=pcs1->pNext;    
        while (pcs2!=NULL)    
         {//此时有进程在等待的话，说明有进程在队列里面       
          if (pcs2->pArriveTime/1000<=sysTime)        
             {printf("进程 %s 在进程队列里等待运行.\n",pcs2->pName);       
              }      
          pcs2=pcs2->pNext;    
         }   
        sysTime++;   
        printf("\n");  
        }  
        //单个进程的调度时间  
        timeUsed=sysTime-pcs1->pArriveTime/1000;   
        //将进程状态设置为执行完的状态 
        pcs1->pState='C';  
        printf("进程 %s 终止运行.\n",pcs1->pName); 
        printf("进程调度时间 timeUsed:%3d.\n\n",timeUsed);   
        //进程调度的总时间 
        totalTimeUsed=totalTimeUsed+timeUsed;   
        timeUsed=0;   
        //将pcs1指向下一个元素   
 pcs2=pcs1;   
pcs1=pcs1->pNext;  
 head_input.pNext=pcs1;  
 //将此进程从进程队列里面删除   
delete pcs2;
 }
}    //ExecProcessList()结束；
//输出各任务的周转时间以及平均周转时间
printf("所有进程总的调度时间 totalTimeUsed:%3d.\n",totalTimeUsed);
printf("所有进程平均调度时间 timeUsed:%lf.\n",(double)totalTimeUsed/(double)num);
}
//定义主函数void main()
{//设置系统当前时间为0
sysTime=0;
//创建进程链表
CreateProcessList();
//依次执行进程
ExecProcessList();
}